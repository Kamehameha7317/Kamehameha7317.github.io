<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity[UGUI]EventSystem.current.currentSelectedGameObject==NULL</title>
    <link href="/2022/08/10/Unity%5BUGUI%5DEventSystem.current.currentSelectedGameObject==NULL/"/>
    <url>/2022/08/10/Unity%5BUGUI%5DEventSystem.current.currentSelectedGameObject==NULL/</url>
    
    <content type="html"><![CDATA[<h1 id="EventSystem-current-currentSelectedGameObject"><a href="#EventSystem-current-currentSelectedGameObject" class="headerlink" title="EventSystem.current.currentSelectedGameObject"></a>EventSystem.current.currentSelectedGameObject</h1><p><em>The GameObject currently considered active by the EventSystem.</em></p><ul><li>EventSystem 当前认为处于活动状态的游戏对象<h1 id="报空场景"><a href="#报空场景" class="headerlink" title="报空场景"></a>报空场景</h1></li><li>获取鼠标点击Toggle时报空，原因是Toggle的Navigation设置为了None，换成Automatic后正常，<h1 id="UnityUI的Navigation"><a href="#UnityUI的Navigation" class="headerlink" title="UnityUI的Navigation"></a>UnityUI的Navigation</h1>设置为None后不再接收鼠标点击的焦点。<br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/20220810151253.png" alt="20220810151253"><br>可手动设置Selected状态在保持None的状态下，得到currentSelectedGameObject<ol><li>设置EventSystem的firstSelected<br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/20220810151725.png" alt="20220810151725"> </li><li>通过代码<code>EventSystem.current.SetSelectedGameObject()</code>直接设置SetSelected。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Component</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity[Tips]利用属性切换物体显示隐藏</title>
    <link href="/2022/07/28/Unity%5BTips%5D%E5%88%A9%E7%94%A8%E5%B1%9E%E6%80%A7%E5%88%87%E6%8D%A2%E7%89%A9%E4%BD%93%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F/"/>
    <url>/2022/07/28/Unity%5BTips%5D%E5%88%A9%E7%94%A8%E5%B1%9E%E6%80%A7%E5%88%87%E6%8D%A2%E7%89%A9%E4%BD%93%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-中的属性"><a href="#C-中的属性" class="headerlink" title="C#中的属性"></a>C#中的属性</h1><ul><li>访问属性时，其行为类似于字段。 但与字段不同的是，属性通过访问器实现；<strong>访问器用于定义访问属性或为属性赋值时执行的语句。</strong><h1 id="属性语法"><a href="#属性语法" class="headerlink" title="属性语法"></a>属性语法</h1></li><li>属性语法是字段的自然延伸。 字段定义存储位置，</li><li>属性定义包含<code>get</code> 和 <code>set</code> 访问器的声明，这两个访问器用于检索该属性的值以及对其赋值。<figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h1></li><li>点击按钮，显示对应的形状，其他形状隐藏<br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/2022-07-28-11-29-59.png" alt="2022-07-28-11-29-59"><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1></li><li>控制脚本<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UIObjectView</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">//存储所有形状</span><br>    <span class="hljs-keyword">public</span> GameObject[] objects;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> currentObject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> CurrentObject<br>    &#123;<br>        <span class="hljs-keyword">get</span> =&gt; currentObject;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            currentObject = <span class="hljs-keyword">value</span>; <br>            UpdateObject();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateObject</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.Length; i++)<br>        &#123;<br>            objects[i].SetActive(i==currentObject);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>调用脚本,当调用<code>CurrentObject</code>赋值时执行<code>UIObjectView</code>中<code>CurrentObject</code>的<code>Set</code>方法，实现更新物体显示隐藏。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UIObjectView uiObjectView;<br>    <span class="hljs-comment">//按钮点击事件，根据按钮名称添加index（1、2、3、4）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSelectObjectClick</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>    &#123;<br>        uiObjectView.CurrentObject = index - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity[Camera]改变正交模式的Size控制RenderTexture画面显示范围</title>
    <link href="/2022/07/27/Unity%5BCamera%5D%E6%94%B9%E5%8F%98%E6%AD%A3%E4%BA%A4%E6%A8%A1%E5%BC%8F%E7%9A%84Size%E6%8E%A7%E5%88%B6RenderTexture%E7%94%BB%E9%9D%A2%E6%98%BE%E7%A4%BA%E8%8C%83%E5%9B%B4/"/>
    <url>/2022/07/27/Unity%5BCamera%5D%E6%94%B9%E5%8F%98%E6%AD%A3%E4%BA%A4%E6%A8%A1%E5%BC%8F%E7%9A%84Size%E6%8E%A7%E5%88%B6RenderTexture%E7%94%BB%E9%9D%A2%E6%98%BE%E7%A4%BA%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="Size的定义"><a href="#Size的定义" class="headerlink" title="Size的定义"></a>Size的定义</h1><ul><li>Unity文档：The viewport size of the Camera when set to Orthographic.当选择正交模式的视窗大小。<br>所谓Size是当前正交摄像机屏幕高度的一半的值，值按照unity单位长度来计算。        </li><li>下图所示Cube的scale是(5,5,5),正交相机的Size是5，RenderTexture的Size是(1920*1080)，两个高度为5unity单位的Cube正好占满整个屏幕。<br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/1.png" alt="1"><h1 id="Size的使用"><a href="#Size的使用" class="headerlink" title="Size的使用"></a>Size的使用</h1></li><li>使用场景：使用正交摄像机(Orthographic)在RenderTexture上渲染Cube，Cube宽度不固定，保持Cube宽度正好在渲染画面不出边界。<br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/2022-07-27-10-51-18.png" alt="2022-07-27-10-51-18"></li><li>假设当前Cube宽度为60，将Cube在Z方向旋转90度，计算出填充满屏幕正交摄像机的Size需要为30<br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/2022-07-27-11-02-56.png" alt="2022-07-27-11-02-56"><br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/2022-07-27-11-02-30.png" alt="2022-07-27-11-02-30"></li><li>该正交摄像机对应的RenderTextureSize为(1920*1080)，由于更改正交摄像机的Size仅影响屏幕高度，我们可以通过计算长宽比(1080/1920=0.56)得到屏幕长宽对应关系,将正交摄像机的Size值 *0.56即可得到满足宽度需求的结果。<br><img src="https://raw.githubusercontent.com/Kamehameha7317/Img_storage/main/blog/pic/2022-07-27-11-12-19.png" alt="2022-07-27-11-12-19"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Component</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
